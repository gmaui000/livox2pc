// This file is @generated by prost-build.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    utoipa::ToSchema,
    bincode::Encode,
    bincode::Decode,
    bitcode::Encode,
    bitcode::Decode
)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Time {
    #[prost(int32, tag = "1")]
    pub sec: i32,
    #[prost(uint32, tag = "2")]
    pub nanosec: u32,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    utoipa::ToSchema,
    bincode::Encode,
    bincode::Decode,
    bitcode::Encode,
    bitcode::Decode
)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Header {
    #[prost(message, optional, tag = "1")]
    pub stamp: ::core::option::Option<Time>,
    #[prost(string, tag = "2")]
    pub frame_id: ::prost::alloc::string::String,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    utoipa::ToSchema,
    bincode::Encode,
    bincode::Decode,
    bitcode::Encode,
    bitcode::Decode
)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MultiArrayDimension {
    #[prost(string, tag = "1")]
    pub label: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub size: u32,
    #[prost(uint32, tag = "3")]
    pub stride: u32,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    utoipa::ToSchema,
    bincode::Encode,
    bincode::Decode,
    bitcode::Encode,
    bitcode::Decode
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiArrayLayout {
    #[prost(message, repeated, tag = "1")]
    pub dim: ::prost::alloc::vec::Vec<MultiArrayDimension>,
    #[prost(uint32, tag = "2")]
    pub data_offset: u32,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    utoipa::ToSchema,
    bincode::Encode,
    bincode::Decode,
    bitcode::Encode,
    bitcode::Decode
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ByteMultiArray {
    #[prost(message, optional, tag = "1")]
    pub layout: ::core::option::Option<MultiArrayLayout>,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    utoipa::ToSchema,
    bincode::Encode,
    bincode::Decode,
    bitcode::Encode,
    bitcode::Decode
)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Point32 {
    #[prost(float, tag = "1")]
    pub x: f32,
    #[prost(float, tag = "2")]
    pub y: f32,
    #[prost(float, tag = "3")]
    pub z: f32,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    utoipa::ToSchema,
    bincode::Encode,
    bincode::Decode,
    bitcode::Encode,
    bitcode::Decode
)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Point64 {
    #[prost(double, tag = "1")]
    pub x: f64,
    #[prost(double, tag = "2")]
    pub y: f64,
    #[prost(double, tag = "3")]
    pub z: f64,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    utoipa::ToSchema,
    bincode::Encode,
    bincode::Decode,
    bitcode::Encode,
    bitcode::Decode
)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Quaternion {
    #[prost(double, tag = "1")]
    pub x: f64,
    #[prost(double, tag = "2")]
    pub y: f64,
    #[prost(double, tag = "3")]
    pub z: f64,
    #[prost(double, tag = "4")]
    pub w: f64,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    utoipa::ToSchema,
    bincode::Encode,
    bincode::Decode,
    bitcode::Encode,
    bitcode::Decode
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelFloat32 {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(float, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<f32>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    utoipa::ToSchema,
    bincode::Encode,
    bincode::Decode,
    bitcode::Encode,
    bitcode::Decode
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PointCloud {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<Header>,
    #[prost(message, repeated, tag = "2")]
    pub points: ::prost::alloc::vec::Vec<Point32>,
    #[prost(message, repeated, tag = "3")]
    pub channels: ::prost::alloc::vec::Vec<ChannelFloat32>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    utoipa::ToSchema,
    bincode::Encode,
    bincode::Decode,
    bitcode::Encode,
    bitcode::Decode
)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PointField {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub offset: u32,
    #[prost(enumeration = "point_field::PointType", tag = "3")]
    pub datatype: i32,
    #[prost(uint32, tag = "4")]
    pub count: u32,
}
/// Nested message and enum types in `PointField`.
pub mod point_field {
    #[derive(
        serde::Serialize,
        serde::Deserialize,
        utoipa::ToSchema,
        bincode::Encode,
        bincode::Decode,
        bitcode::Encode,
        bitcode::Decode
    )]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PointType {
        None = 0,
        Int8 = 1,
        Uint8 = 2,
        Int16 = 3,
        Uint16 = 4,
        Int32 = 5,
        Uint32 = 6,
        Float32 = 7,
        Float64 = 8,
    }
    impl PointType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Int8 => "INT8",
                Self::Uint8 => "UINT8",
                Self::Int16 => "INT16",
                Self::Uint16 => "UINT16",
                Self::Int32 => "INT32",
                Self::Uint32 => "UINT32",
                Self::Float32 => "FLOAT32",
                Self::Float64 => "FLOAT64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "INT8" => Some(Self::Int8),
                "UINT8" => Some(Self::Uint8),
                "INT16" => Some(Self::Int16),
                "UINT16" => Some(Self::Uint16),
                "INT32" => Some(Self::Int32),
                "UINT32" => Some(Self::Uint32),
                "FLOAT32" => Some(Self::Float32),
                "FLOAT64" => Some(Self::Float64),
                _ => None,
            }
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    utoipa::ToSchema,
    bincode::Encode,
    bincode::Decode,
    bitcode::Encode,
    bitcode::Decode
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PointCloud2 {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<Header>,
    #[prost(uint32, tag = "2")]
    pub height: u32,
    #[prost(uint32, tag = "3")]
    pub width: u32,
    #[prost(message, repeated, tag = "4")]
    pub fields: ::prost::alloc::vec::Vec<PointField>,
    #[prost(bool, tag = "5")]
    pub is_bigendian: bool,
    #[prost(uint32, tag = "6")]
    pub point_step: u32,
    #[prost(uint32, tag = "7")]
    pub row_step: u32,
    #[prost(bytes = "vec", tag = "8")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "9")]
    pub is_dense: bool,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    utoipa::ToSchema,
    bincode::Encode,
    bincode::Decode,
    bitcode::Encode,
    bitcode::Decode
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Imu {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<Header>,
    #[prost(message, optional, tag = "2")]
    pub orientation: ::core::option::Option<Quaternion>,
    #[prost(message, optional, tag = "3")]
    pub angular: ::core::option::Option<Point64>,
    #[prost(message, optional, tag = "4")]
    pub acceleration: ::core::option::Option<Point64>,
    #[prost(double, repeated, tag = "5")]
    pub orientation_covariance: ::prost::alloc::vec::Vec<f64>,
    #[prost(double, repeated, tag = "6")]
    pub angular_covariance: ::prost::alloc::vec::Vec<f64>,
    #[prost(double, repeated, tag = "7")]
    pub acceleration_covariance: ::prost::alloc::vec::Vec<f64>,
    #[prost(enumeration = "imu::State", tag = "8")]
    pub status: i32,
    #[prost(uint32, tag = "9")]
    pub sequence: u32,
    #[prost(int32, tag = "10")]
    pub latency_ms: i32,
    #[prost(float, tag = "11")]
    pub temperature: f32,
    #[prost(bytes = "vec", tag = "12")]
    pub model: ::prost::alloc::vec::Vec<u8>,
    #[prost(float, repeated, tag = "13")]
    pub intrinsics: ::prost::alloc::vec::Vec<f32>,
}
/// Nested message and enum types in `Imu`.
pub mod imu {
    #[derive(
        serde::Serialize,
        serde::Deserialize,
        utoipa::ToSchema,
        bincode::Encode,
        bincode::Decode,
        bitcode::Encode,
        bitcode::Decode
    )]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Ok = 0,
        LostBoth = 1,
        LostA = 2,
        LostB = 3,
        TempHigh = 4,
        Timeout = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Ok => "OK",
                Self::LostBoth => "LOST_BOTH",
                Self::LostA => "LOST_A",
                Self::LostB => "LOST_B",
                Self::TempHigh => "TEMP_HIGH",
                Self::Timeout => "TIMEOUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OK" => Some(Self::Ok),
                "LOST_BOTH" => Some(Self::LostBoth),
                "LOST_A" => Some(Self::LostA),
                "LOST_B" => Some(Self::LostB),
                "TEMP_HIGH" => Some(Self::TempHigh),
                "TIMEOUT" => Some(Self::Timeout),
                _ => None,
            }
        }
    }
}
